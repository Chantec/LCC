#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int token;            
char *src, *old_src;  
int poolsize;         
int line;         



int *text,*old_text,*stack;
char *data;


int *PC,*SP,*BP,ax;


enum {LEA,IMM,JMP,CALL,JZ,JNZ,ENT,ADJ,LEV,LI,LC,SI,SC,PUSH,
       OR,XOR,AND,EQ,NE,LT,GT,LE,GE,SHL,SHR,ADD,SUB,MUL,DIV,MOD,
       OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT};


enum {
  Num = 128, Fun, Sys, Glo, Loc, Id,
  Char, Else, Enum, If, Int, Return, Sizeof, While,
  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak
};




enum {Token, Hash, Name, Type, Class, Value, BType, BClass, BValue, IdSize};




int token_val;

int *curr_id,symbols;


enum { CHAR, INT, PTR };
int *idmain;                 



int basetype;


int index_of_bp;


int expr_type;


void debug_print_stack()
{
    printf("***stack top***\n");
    for(int *i=SP;i<=BP;i++)
        printf("%d\n",*(int *)i);
    printf("***stack***\n");
}



void next() 
{
    char *id_begin;
    int hash;

    while(token=*src)
    {
        src++;
        if(token=='\n')
            line++;
        else if(token=='#')
        {
            
            while(*src!=0&&*src!='\n')
                src++;
        }
        
        else if(token>='a'&&token<='z'||token>='A'&&token<='Z'||token=='_')
        {
            id_begin=src-1;
            hash=token;

            while(*src>='a'&&*src<='z'||*src>='A'&&*src<='Z'||*src=='_'||*src>='0'&&*src<='9')
            {
                hash=hash*147+*src;
                src++;
            }

            
            
            
            

                
            
            

            curr_id=symbols;
            while(curr_id[Token])
            {
                if(curr_id[Hash]==hash&&memcmp((char*)curr_id[Name],id_begin,src-id_begin)==0)
                
                {
                    
                    token=curr_id[Token];
                    return ;
                }
                curr_id+=IdSize;
            }

           

            
            curr_id[Token]=Id;
            curr_id[Hash]=hash;
            curr_id[Name]=(int)id_begin;
            token=Id;
            return ;
        }
        
        else if(token>='0'&&token<='9')
        {
            token_val=token-'0';
            while(*src>='0'&&*src<='9')
            {
                token_val=token_val*10+*src-'0';
                src++;
            }
            token=Num;
            return ;
        }
        
        else if(token=='\''||token=='"')
        {
            id_begin=data;
            while (*src != 0 && *src != token)
            {
                if((token_val=*src++)=='\\')
                {
                    if((token_val=*src++)=='n')
                        token_val='\n';
                }
                if(token=='"') *data++=token_val;
                
            }
            src++;
            if(token=='"') 
                token_val=(int)id_begin;
            else 
                token=Char;

            
            
            
            
            return;
        }

        else if(token=='/')
        {
            if(*src=='/')
            {
                while(*src!=0&&*src!='\n')
                    src++;
            }
            else 
            {
                token==Div;
                return ;
            }
        }
        else if(token=='=')
        {
            if(*src=='=')
            {
                src++;
                token=Eq;
            }
            else 
            {
                token=Assign;
            }
            return ;
        }
        else if(token=='<')
        {
            if(*src=='=')
            {
                src++;
                token=Le;
            }
            else if(*src=='<')
            {
                src++;
                token=Shl;
            }
            else 
            {
                token=Lt;
            }
            return ;
        }
        else if(token=='>')
        {
            if(*src=='=')
            {
                src++;
                token=Ge;
            }
            else if(*src=='>')
            {
                src++;
                token=Shr;
            }
            else 
            {
                token=Gt;
            }
            return ;
        }
        else if(token=='!')
        {   
            if(*src=='=')
            {
                token=Ne;
                src++;
            }
            return ;
        }
        else if(token=='|')
        {
            if(*src=='|')
            {
                src++;
                token=Lor;
            }
            else 
            {
                token=Or;
            }
            return ;
        }
        else if(token=='&')
        {
            if(*src=='&')
            {
                src++;
                token=Lan;
            }
            else 
            {
                token=And;
            }
            return ;
        }
        else if(token=='+')
        {
            if(*src=='+')
            {
                src++;
                token=Inc;
            }
            else
            {
                token=Add;
            }
            return ;
        }
        else if(token=='-')
        {
            if(*src=='-')
            {
                src++;
                token=Dec;
            }
            else 
            {
                token=Sub;
            }
            return ;
        }
        else if(token=='^')
        {
            token=Xor;
            return ;
        }
        else if(token=='*')
        {
            token=Mul;
            return ;
        }
        else if(token=='%')
        {
            token=Mod;
            return ;
        }
        else if(token=='[')
        {
            token=Brak;
            return ;
        }
        else if(token=='?')
        {
            token=Cond;
            return ;
        }
        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') 
        {
            return;
        }
    }
    return ;
}

void match(int tk)
{
    if(token!=tk)
    {
        printf("%d: expected token: %d %c\n", line, tk,tk);
        printf("current token : char:%c int:%d\n",token,token);
        exit(-1);
    }
    else 
        next();
}



void expression(int level) 
{
    int *this_id;
    int tmp;
    if(token==Num)
    {
        match(Num);

        *++text=IMM;
        *++text=token_val;
        expr_type=INT;
    }
    else if(token=='"')
    {
        
        *++text=IMM;
        *++text=token_val;

        match('"');

        
        
        data = (char *)(((int)data + sizeof(int)) & (-sizeof(int)));
        expr_type = PTR;
    }
    
    else if(token==Id)
    {
        this_id=curr_id;
        match(Id);

        
        if(token=='(')
        {
            tmp=0;
            match('(');
            while(token!=')')
            {
                
                expression(Assign);

                *++text=PUSH;
                tmp++;
                if(token!=')')
                    match(',');
            }
            match(')');

            if(this_id[Class]==Sys)
            {
                
                *++text=this_id[Value];
            }
            else if(this_id[Class]==Fun)
            {
                
                *++text=CALL;
                *++text=this_id[Value];
            }
            else 
            {
                printf("%d: bad func call\n",line);
                exit(-1);
            }

            
            if(tmp>0)
            {
                *++text=ADJ;
                *++text=tmp;
            }
            expr_type = this_id[Type];
        }
        else if(this_id[Class]==Num)
        {
            
            
        }
        else 
        {
            
            if(this_id[Class]==Glo)
            {
                *++text=IMM;
                *++text=this_id[Value];
            }
            else if(this_id[Class]==Loc)
            {
                *++text=LEA;
                *++text=index_of_bp-this_id[Value];
                
                
                
            }
            else 
            {
                printf("%d: undefined var\n", line);
                exit(-1);
            }
            
            expr_type = this_id[Type];
            *++text = (expr_type == CHAR) ? LC : LI;
        }
    }
    else if(token=='(')
    {
        
    }
    else if(token==Mul)
    {
        
    }
    else if(token==And)
    {
        
    }
    else if(token=='!')
    {
        
    }
    else if(token=='~')
    {
        
    }
    else if(token==Add)
    {
        
    }
    else if(token==Sub)
    {
        
    }
    else if(token==Inc||token==Dec)
    {
        
    }




    tmp = expr_type;
    
    if(token==Assign)
    {
        match(Assign);
        if(*text==LC||*text==LI)
        {
            *text=PUSH;
        }
        else 
        {
            printf("%d: bad lvalue in assignment\n", line);
            exit(-1);
        }
        expression(Assign);
        expr_type = tmp;
        *++text = (expr_type == CHAR) ? SC : SI;
    }










}


void statement()
{
    
    
    
    
    
    
    
    

    
    
    
    
    
    


    int *a,*b;

    if(token==If)
    {
        match(If);
        match('(');
        expression(Assign);
        match(')');

        *++text=JZ;
        a=++text;

        statement();

        if(token==Else)
        {
            match(Else);

            *++text=JMP;
            b=++text;

            *a=(int)(text+1);

            statement();

            *b=(int)(text+1);   
        }
        else 
        {
            *a=(int)(text+1);
        }
    }
    else if(token==While)
    {
        match(While);
        
        match('(');
        *a=(int)(text+1);
        expression(Assign);
        match(')');

        *++text=JZ;
        b=++text;

        statement();

        *++text=JMP;
        *++text=*a;
        *b=(int)(text+1);
    }
    else if(token==Return)
    {
        match(Return);

        if(token!=';') 
            expression(Assign);
        
        match(';');

        *++text=LEV;
    }
    else if(token=='{')
    {
        match('{');
        while(token!='}')
            statement();
        match('}');
    }
    else if(token==';')
    {
        match(';');
    }
    else 
    {
        
        expression(Assign);
        match(';');
    }
}
void func_para()
{
    
    int var_type;
    int params;
    params=0;

    while(token!=')')
    {
        
        if(token==INT)
        {
            var_type=INT;
            next();
        }else if(token==Char)
        {
            var_type=CHAR;
            next();
        }

        while(token==Mul)
        {
            var_type=var_type+PTR;
            next();
        }

        
        if(token!=Id)
        {
            printf("%d: bad func para decl\n",line);
            exit(-1);
        }
        if(curr_id[Class]==Loc)
        {
            printf("%d duplicate func para decl\n",line);
            exit(-1);
        }
        match(Id);

        curr_id[BClass] = curr_id[Class]; curr_id[Class]  = Loc;
        curr_id[BType]  = curr_id[Type];  curr_id[Type]   = var_type;
        curr_id[BValue] = curr_id[Value]; curr_id[Value]  = params++; 

        if(token!='}')
            match(',');
    }
    index_of_bp=params+1;


}
void func_body()
{
    
    int var_type;
    int pos_var;
    pos_var=index_of_bp;

    
    while(token==Int||token==Char)
    {
        if(token==Int)
        {
            basetype=INT;
            next();
        }
        else if(token==Char)
        {
            basetype=CHAR;
            next();
        }

        while(token!=';')
        {
            var_type=basetype;
            while(token==Mul)
            {
                var_type=var_type+PTR;
                next();
            }
            if (token!=Id) 
            {
                printf("%d: bad local decl\n", line);
                exit(-1);
            }
            if (curr_id[Class] == Loc)
            {
                printf("%d: duplicate local decl\n", line);
                exit(-1);
            }
            match(Id);
            

            curr_id[BClass] = curr_id[Class]; curr_id[Class]  = Loc;
            curr_id[BType]  = curr_id[Type];  curr_id[Type]   = var_type;
            curr_id[BValue] = curr_id[Value]; curr_id[Value]  = ++pos_var;   

            if(token!=';')
                match(',');
        }
        match(';');
    }

    
    *++text=ENT;
    *++text=pos_var-index_of_bp;

    while(token!='}')
        statement();
    
    *++text=LEV;

}
void func_decl()
{
    
    match('(');
    func_para();
    match(')');
    match('{');
    func_body();
    match('}');

    
    curr_id=symbols;
    while(curr_id[Token])
    {
        if(curr_id[Class]==Loc)
        {
            curr_id[Class]=curr_id[BClass];
            curr_id[Type]=curr_id[BType];
            curr_id[Value]=curr_id[BValue];
        }
        curr_id=curr_id+IdSize;
    }
}
void enum_decl()
{
    
    

    int i;
    i=0;
    while(token!='}')
    {
        if(token!=Id)
        {
            printf("%d: bad enum id %d\n",line,token);
            exit(-1);
        }
        next();
        if(token==Assign)
        {
            next();
            if(token!=Num)
            {
                printf("%d: bad enum init\n",line);
                exit(-1);
            }
            i=token_val;
            next();
        }

        
        curr_id[Class]=Num;
        curr_id[Type]=INT;
        curr_id[Value]=i++;

        if(token==',') next();
    }
}

void global_decl()
{

    

    

    

    


    int var_type;


    if(token==Enum)
    {
        next();
        if(token!='{')
            match(Id);
        match('{');
        enum_decl();
        match('}');
        match(';');
        return ;
    }
    
    
    if(token==Int)
    {
        basetype=INT;
        next();
    }
    else if(token==Char)
    {
        basetype=CHAR;
        next();
    }
    
    var_type=basetype;
    while(token==Mul)
    {
        var_type=var_type+PTR;
        next();
    }
    if(token!=Id)
    {
        printf("%d: bad global decl\n",line);
        exit(-1);
    }
    
    if(curr_id[Class])
    {
        printf("%d: duplicate global decl\n",line);
        exit(-1);
    }

    match(Id);

    if(token=='(')
    {
        curr_id[Class]=Fun;
        curr_id[Type]=var_type;
        curr_id[Value]=(int)(text+1);
        func_decl();
        return ;

    }
    
    curr_id[Type]=var_type;
    curr_id[Class]=Glo;
    curr_id[Value]=(int)data;
    data=data+sizeof(int);


    while(token!=';')
    {
        match(',');
        
        var_type=basetype;
        while(token==Mul)
        {
            var_type=var_type+PTR;
            next();
        }
        if(token!=Id)
        {
            printf("%d: bad global decl\n",line);
            exit(-1);
        }
        
        if(curr_id[Class])
        {
            printf("%d: duplicate global decl\n",line);
            exit(-1);
        }
        next();

        curr_id[Type]=var_type;
        curr_id[Class]=Glo;
        curr_id[Value]=(int)data;
        data=data+sizeof(int);
    }
}

void program() 
{
    next();                 
    while (token > 0)
    {
        global_decl();
    }
}

int eval() 
{
    int op,*tmp;
    while(1)
    {
        op=*PC++;
        if(op==IMM) 
        {
            ax=*PC++;
        }
        else if(op==LC)
        {
            ax=*(char *)ax;
        } 
        else if(op==LI)
        {
            ax=*(int *)ax;
        }
        else if(op==SC)
        {
            *(char *)*SP=ax;
            SP++;
        }
        else if(op==SI)
        {
            *(int *)*SP=ax;
            SP++;
        }
        else if(op==PUSH)
        {
            *(--SP)=ax;
        }
        else if(op==JMP)
        {
            PC=(int *)*PC;
        }
        else if(op==JZ)
        {
            PC=ax?PC+1:(int *)*PC;
        }
        else if(op==JNZ)
        {
            PC=ax?(int *)*PC:PC+1;
        }
        else if(op==CALL)
        {
            *(--SP)=(int)(PC+1);
            PC=(int *)*PC;
        }
        else if(op==ENT)
        {
            *(--SP)=(int)BP;
            BP=SP;
            SP=SP-*PC++;
        }
        else if(op==ADJ)
        {
            SP=SP+*PC++;
        }
        else if(op==LEV)
        {
            SP=BP;
            BP=(int*)*SP++;
            PC=(int*)*SP++;
        }
        else if(op==LEA)
        {
            ax=(int)(BP+*PC++);
        }
        else if (op == OR)  ax = *SP++ | ax;
        else if (op == XOR) ax = *SP++ ^ ax;
        else if (op == AND) ax = *SP++ & ax;
        else if (op == EQ)  ax = *SP++ == ax;
        else if (op == NE)  ax = *SP++ != ax;
        else if (op == LT)  ax = *SP++ < ax;
        else if (op == LE)  ax = *SP++ <= ax;
        else if (op == GT)  ax = *SP++ >  ax;
        else if (op == GE)  ax = *SP++ >= ax;
        else if (op == SHL) ax = *SP++ << ax;
        else if (op == SHR) ax = *SP++ >> ax;
        else if (op == ADD) ax = *SP++ + ax;
        else if (op == SUB) ax = *SP++ - ax;
        else if (op == MUL) ax = *SP++ * ax;
        else if (op == DIV) ax = *SP++ / ax;
        else if (op == MOD) ax = *SP++ % ax;
        else if (op == EXIT) { printf("exit(%d)", *SP); return *SP;}
        else if (op == OPEN) { ax = open((char *)SP[1], SP[0]); }
        else if (op == CLOS) { ax = close(*SP);}
        else if (op == READ) { ax = read(SP[2], (char *)SP[1], *SP); }
        else if (op == PRTF) { tmp = SP + PC[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }
        else if (op == MALC) { ax = (int)malloc(*SP);}
        else if (op == MSET) { ax = (int)memset((char *)SP[2], SP[1], *SP);}
        else if (op == MCMP) { ax = memcmp((char *)SP[2], (char *)SP[1], *SP);}
        else 
        {
            printf("unknown instruction:%d\n", op);
            return -1;
        }
    }
    return 0;
}

int main(int argc, char **argv)
{
   
    int i, fd;

    int *tmp;
    

    argc--;
    argv++;

    poolsize = 256 * 1024; 
    line = 1;

    

    
    
    
    if((text=old_text=malloc(poolsize))==NULL||(data=malloc(poolsize))==NULL||(stack=malloc(poolsize))==NULL)
    {
        printf("could not malloc for vm");
        return -1;
    }
     if (!(symbols = malloc(poolsize))) {
        printf("could not malloc for symbol table\n");
        return -1;
    }
    
    memset(text,0,poolsize);
    memset(data,0,poolsize);
    memset(stack,0,poolsize);

    
    SP=BP=(int*)((int)stack+poolsize);
    PC=0;
    ax=0;

    
    

    src = "char else enum if int return sizeof while "
          "open read close printf malloc memset memcmp exit void main";

    i=Char;
    while(i<=While)
    {
        next();
        curr_id[Token]=i++;
    }

    

    i=OPEN;
    while(i<=EXIT)
    {
        next();
        curr_id[Class]=Sys;
        curr_id[Type]=INT;
        curr_id[Value]=i++;
    }

    next();curr_id[Token]=Char;
    next();idmain=curr_id;


    
    
    
    if ((fd = open(*argv, 0)) < 0)
    {
        printf("could not open(%s)\n", *argv);
        return -1;
    }

    if (!(src = old_src = malloc(poolsize))) {
        printf("could not malloc(%d) for source area\n", poolsize);
        return -1;
    }

    
    if ((i = read(fd, src, poolsize-1)) <= 0)
    {
        printf("read() returned %d\n", i);
        return -1;
    }
    src[i] = 0; 
    close(fd);
    


    program();

    if (!(PC = (int *)idmain[Value]))
    {
        printf("main() not defined\n");
        return -1;
    }

    
    
    SP = (int *)((int)stack + poolsize);
    *--SP = EXIT; 
    *--SP = PUSH; tmp = SP;
    *--SP = argc;
    *--SP = (int)argv;
    *--SP = (int)tmp;
    

    
    return eval();

   



    
}
